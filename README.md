# Thread_Sort

## Описание
Проект представляет собой многопоточное приложение на C++, которое выполняет сортировку больших объёмов данных. Процесс включает в себя чтение данных из файла, раздление данных между потоками, сортировку (merge sort), и объединение результатов в единый файл. 

## Как использовать 

### Сборка и запуск проека
```
g++ -o main main.cpp -std=c++11 -pthread
```

```
./main
```

## Структура проекта

- safe_queue.hpp/save_queue.cpp: заголовочный файл и реализация безопасной очереди для обмена данными между потоками.
- main.cpp: основной файл с реализацией многопоточного приложения

## Как работает

1) Генерируется тестовый файл с случайными числами.
2) Запускается несколько потоков, каждый из которых считывает часть данных из файла, сортирует ее и записывает в новый файл.
3) После завершения сорировки запускается процесс объединения отсортированных файлов в один. 
4) В конце работы выводится время выполнения и имя конечного файла.

## Замечания

* Размер части данных для сортировки установлен 50 МБ, вы можете изменить это значение в соответствии с вашими требованиями. 
* Результаты сортировки сохраняются в файлы "resX_threadId.bin", а файл после объединения будет иметь имя вида "mer_X_threadId.bin"

## Про потокобезопасную очередь

Принципы работы потокобезопасной очереди включают в себя использование мьютексов (механизм блокировки) для синхронизации доступа к общим данным. Вот основные компоненты и принципы потокобезопасной очереди:

- Мьютексы (Mutexes): Мьютексы используются для блокировки доступа к общим данным в момент, когда один поток пытается изменить состояние очереди. Если один поток уже работает с очередью, другие потоки ждут, пока мьютекс не будет освобожден.
- Условные переменные (Condition Variables): Условные переменные используются для оповещения ожидающих потоков о том, что какое-то событие произошло. Они позволяют потокам ожидать сигнала от других потоков о том, что определенное условие стало истинным.
- Атомарные операции: Атомарные операции гарантируют, что операция выполняется целиком, без возможности прерывания другими потоками. В контексте потокобезопасной очереди, это важно при выполнении операций добавления и извлечения элементов.

В проекте используются **std::lock_guard** и **std::unique_lock** для автоматического освобождения мьютекса при выходе из блока. **std::condition_variable** используется для ожидания, когда очередь не пуста перед извлечением элемента. Это позволяет потокам эффективно спать, когда нет работы, и просыпаться при появлении новых данных.

Это всего лишь простой пример, и реальные реализации могут включать дополнительные механизмы для обработки ошибок, улучшения производительности и т. д.
